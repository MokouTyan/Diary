【2022.12.28】kaggle上泰坦尼克号的实操

### 前言

经过一系列的学习，现在想入门kaggle上面的实操，多为模仿

参考链接：[机器学习入门：Kaggle -titanic(泰坦尼克)生存预测](https://blog.csdn.net/cutenew52188/article/details/123710959)

```python
# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session



import warnings 
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# 忽略部分版本警告
warnings.filterwarnings('ignore')
#设置sns样式
sns.set(style='white',context='notebook',palette='muted')
#导入数据
train=pd.read_csv('/kaggle/input/titanic/train.csv')
test=pd.read_csv('/kaggle/input/titanic/test.csv')

```

使用info可以了解到如下信息

```python
train.info()

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
 #   Column       Non-Null Count  Dtype  
---  ------       --------------  -----  
 0   PassengerId  891 non-null    int64  # 乘客ID
 1   Survived     891 non-null    int64  # 是否存活
 2   Pclass       891 non-null    int64  # 客舱等级(1/2/3等舱位)
 3   Name         891 non-null    object # 乘客姓名
 4   Sex          891 non-null    object # 性别
 5   Age          714 non-null    float64 # 年龄
 6   SibSp        891 non-null    int64  # 兄弟姐妹数/配偶数
 7   Parch        891 non-null    int64  # 父母数/子女数
 8   Ticket       891 non-null    object # 船票编号
 9   Fare         891 non-null    float64 # 船票价格
 10  Cabin        204 non-null    object # 客舱号
 11  Embarked     889 non-null    object # 登船港口
dtypes: float64(2), int64(5), object(5)
memory usage: 83.7+ KB
```

其中可以看到，有一些年龄和客舱号是空缺的（不足891）

而在test.info()之中，可以看到只有11列，去掉了存活

### seaborn画图

```python
# 计算不同类型embarked的乘客，其生存率为多少
print('Embarked为"S"的乘客，其生存率为%.2f' % full['Survived'][full['Embarked'] == 'S'].value_counts(normalize=True)[1])
print('Embarked为"C"的乘客，其生存率为%.2f' % full['Survived'][full['Embarked'] == 'C'].value_counts(normalize=True)[1])
print('Embarked为"Q"的乘客，其生存率为%.2f' % full['Survived'][full['Embarked'] == 'Q'].value_counts(normalize=True)[1])

###
Embarked为"S"的乘客，其生存率为0.34
Embarked为"C"的乘客，其生存率为0.55
Embarked为"Q"的乘客，其生存率为0.39
###
```



#### sns.catplot分类型数据作坐标轴画图

```python
sns.catplot('Pclass', col='Embarked', data=train, kind='count', height=3)
```

这句话的意思是 根据Pclass和Embarked分类表格，并统计Pclass的数据

![image-20221228144145701](https://i0.hdslb.com/bfs/album/1217e1e6f0e9a954c2102a190f4fa5b539e811fa.png)

S是英国，C是法国，Q是新西兰

法国登船乘客生存率较高原因可能与其头等舱乘客比例较高有关。

#### sns.barplot柱状图

```python
# Sex与Survived：女性的生存率远高于男性
sns.barplot(data=train, x='Sex', y='Survived')
```

![image-20221228145004731](https://i0.hdslb.com/bfs/album/059281af337aa1698c0453ec642ac9a2bc2c0193.png)

其中每个柱条的黑色的线条为误差线
误差线源于统计学，表示数据误差(或不确定性)范围，以更准确的方式呈现数据。误差线可以用标准差(standard deviation,SD)、标准误(standard error,SE)和置信区间表示，使用时可选用任意一种表示方法并作相应说明即可。当误差线比较“长”时，一般要么是数据离散程度大，要么是数据样本少。

#### sns.FacetGrid

```python
ageFacet = sns.FacetGrid(train, hue='Survived', aspect=3)    # 创建坐标轴
ageFacet.map(sns.kdeplot, 'Age', shade=True)                 # 作图，选择图形类型
ageFacet.set(xlim=(0, train['Age'].max()))                   # 其他信息：坐标轴范围、标签等
ageFacet.add_legend()
```

 Age与Survived：当乘客年龄段在0-10岁期间时生存率会较高。

![image-20221228145614717](https://i0.hdslb.com/bfs/album/a5e09a8b656d6350448365bbb2d5014a35a02811.png)

### 数据预处理

先对表格的缺失值进行处理

#### 字符类处理

其中有两个人没有进站数据，经过绘图我们可以知道大部分人都是S站上船的

因此我们直接填入S

![image-20221228151250504](https://i0.hdslb.com/bfs/album/6720265c2a0791185b9bd79beb35ce734b8a929e.png)

因为cabin的数据量太少，因此将空缺的地方直接填入Unknown

```python
full['Cabin']=full['Cabin'].fillna('Unknown')
full['Embarked']=full['Embarked'].fillna('S')
```

#### 数值类处理

有一个人没有票价，因此填入平均值

```python
full[full['Fare'].isnull()]
# 查询可知
#PassengerId	Survived	Pclass	Name	Sex	Age	SibSp	Parch	Ticket	Fare	Cabin	Embarked
#1043	1044	NaN	3	Storey, Mr. Thomas	male	60.5	0	0	3701	NaN	Unknown	S
# 利用3等舱，登船港口为英国，舱位未知旅客的平均票价来填充缺失值。
full['Fare']=full['Fare'].fillna( full[(full['Pclass']==3)&(full['Embarked']=='S')&(full['Cabin']=='Unknown')]['Fare'].mean())
```

而age没有填入数值，但是这个数据很大概率影响到存活率，这个放到下面的特征工程讲

### 特征工程

#### 身份头衔特征

合并一些有相同特征的标签，“暴力更改”部分标签，在泰坦尼克的数据中，姓名头衔可以很好反应这一点。比如有的人是Dr，Mrs等

```python
#构造新特征Title
full['Title']=full['Name'].map(lambda x:x.split(',')[1].split('.')[0].strip())
#查看title数据分布
full['Title'].value_counts()
```

新建新的特征Title，分割出逗号和句号之间的身份

![image-20221228155923469](https://i0.hdslb.com/bfs/album/3b72c3d1c31efed7b6d05e7cfdde657b44169de0.png)

其中有的是头衔，有的并不是头衔，Capt这类就是船长啥的，因此我们要将一些特征合并在一起，可以采用上面的方法对数据进行修改，也可以采用词典的方法对结果进行整合

```python
TitleDict={}
TitleDict['Mr']='Mr'
TitleDict['Mlle']='Miss'
TitleDict['Miss']='Miss'
TitleDict['Master']='Master'
TitleDict['Jonkheer']='Master'
TitleDict['Mme']='Mrs'
TitleDict['Ms']='Mrs'
TitleDict['Mrs']='Mrs'
TitleDict['Don']='Royalty'
TitleDict['Sir']='Royalty'
TitleDict['the Countess']='Royalty'
TitleDict['Dona']='Royalty'
TitleDict['Lady']='Royalty'
TitleDict['Capt']='Officer'
TitleDict['Col']='Officer'
TitleDict['Major']='Officer'
TitleDict['Dr']='Officer'
TitleDict['Rev']='Officer'
 
full['Title']=full['Title'].map(TitleDict)
```

再次使用value_counts()时，可以得到以下整合后的效果

![image-20221228160434663](https://i0.hdslb.com/bfs/album/be13e8ab85e6d6737279822c2bb395e5597ba485.png)

观察结果

```python
# 观察新特征与标签之间的关系
sns.barplot(data=full,x='Title',y='Survived')
# 头衔为'Mr'及'Officer'的乘客，生存率明显较低。
```

![image-20221228162534846](https://i0.hdslb.com/bfs/album/aba457ac7fc2cc8e7dc93c235b8b9912f5e9fbe7.png)

贵族和女士的生存率较高

#### 家庭成员特征

拖家带口和独自一人的存活率可能会有差异，可以通过数据表体现出来

```python
full['familyNum']=full['Parch']+full['SibSp']+1
# 查看familyNum与Survived
sns.barplot(data=full,x='familyNum',y='Survived')
```

![image-20221228161606779](https://i0.hdslb.com/bfs/album/8296660f95c0e97e10ff23ce335aa2f90b4b1218.png)

可以看出8，11人的家庭没有存活，4人口的存活率最高

可以将家庭分为小中大三类

```python
# 按照家庭成员人数多少，将家庭规模分为“小、中、大”三类：
def familysize(familyNum):
    if familyNum==1:
        return 0
    elif (familyNum>=2)&(familyNum<=4):
        return 1
    else:
        return 2
 
full['familySize']=full['familyNum'].map(familysize)
full['familySize'].value_counts()
'''
0    790
1    437
2     82
Name: familySize, dtype: int64
'''
# 查看familySize与Survived
sns.barplot(data=full,x='familySize',y='Survived')
# 当家庭规模适中时，乘客的生存率更高。
```

![image-20221228162036180](https://i0.hdslb.com/bfs/album/195c3aae5963e1925460ace94d837faab0abe7d2.png)

#### 船舱类型特征

```python
# Cabin字段的首字母代表客舱的类型
# 也反映不同乘客群体的特点，可能也与乘客的生存率相关。
#提取Cabin字段首字母
full['Deck']=full['Cabin'].map(lambda x:x[0])
#查看不同Deck类型乘客的生存率
sns.barplot(data=full,x='Deck',y='Survived')
# 当乘客的客舱类型为B/D/E时，生存率较高；当客舱类型为U/T时，生存率较低。
# Unknown的生存率较低
```

![image-20221228163103493](https://i0.hdslb.com/bfs/album/8d9d21a8f2d7c45e53eeb23115534534b77d3f03.png)

#### 共票号乘客特征

```python
# 同一票号的乘客数量可能不同，可能也与乘客生存率有关系。
# 提取各票号的乘客数量
TickCountDict={}
TickCountDict=full['Ticket'].value_counts()
TickCountDict.head()
#将同票号乘客数量数据并入数据集中
full['TickCot']=full['Ticket'].map(TickCountDict)
full['TickCot'].value_counts()
# 查看TickCot与Survived之间关系
sns.barplot(data=full,x='TickCot',y='Survived')
# 当TickCot大小适中时，乘客生存率较高。
```

![image-20221228165826445](https://i0.hdslb.com/bfs/album/9cdf7b0bbff2f1f3c551d6277899fd4a40767efe.png)

```python
#按照TickCot大小，将TickGroup分为三类。
def TickCountGroup(num):
    if (num==1):
        return 0
    elif (num>=2)&(num<=4):
        return 1
    else :
        return 2
#得到各位乘客TickGroup的类别
full['TickGroup']=full['TickCot'].map(TickCountGroup)
#查看TickGroup与Survived之间关系
sns.barplot(data=full,x='TickGroup',y='Survived')
```

![image-20221228170835721](https://i0.hdslb.com/bfs/album/235f5e41a03a6be031f695c411d30d1216f8247d.png)

### 数值补全

进行以上数据处理和特征工程后，数据变得很完整，就可以着手预测年龄的，

### 参考链接

[超详细Seaborn绘图 ——（一）barplot](https://blog.csdn.net/Artoria_QZH/article/details/102768817)
